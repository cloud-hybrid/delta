/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as aws from "./.gen/providers/aws";
const securityGroupsPing =
  "${var.enable_ping && length(var.gitlab_runner_security_group_ids) > 0 ? concat(var.gitlab_runner_security_group_ids, [aws_security_group.runner.id]) : []}";
const awsSecurityGroupDockerMachine = new aws.vpc.SecurityGroup(
  this,
  "docker_machine",
  {
    description: "${var.docker_machine_security_group_description}",
    egress: [],
    namePrefix: "${local.name_sg}-docker-machine",
    tags: '${merge(\n    local.tags,\n    {\n      "Name" = format("%s", local.name_sg)\n    },\n  )}',
    vpcId: "${var.vpc_id}",
  }
);

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsSecurityGroupDockerMachine.addOverride("egress", {
  for_each: "${var.docker_machine_egress_rules}",
  content: [
    {
      cidrBlocks: "${each.value.cidr_blocks}",
      description: "${each.value.description}",
      fromPort: "${each.value.from_port}",
      ipv6CidrBlocks: "${each.value.ipv6_cidr_blocks}",
      prefixListIds: "${each.value.prefix_list_ids}",
      protocol: "${each.value.protocol}",
      securityGroups: "${each.value.security_groups}",
      self: "${each.value.self}",
      toPort: "${each.value.to_port}",
    },
  ],
});
const awsSecurityGroupRunner = new aws.vpc.SecurityGroup(this, "runner", {
  description: "${var.gitlab_runner_security_group_description}",
  egress: [],
  namePrefix: "${local.name_sg}",
  tags: '${merge(\n    local.tags,\n    {\n      "Name" = format("%s", local.name_sg)\n    },\n  )}',
  vpcId: "${var.vpc_id}",
});

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsSecurityGroupRunner.addOverride("egress", {
  for_each: "${var.gitlab_runner_egress_rules}",
  content: [
    {
      cidrBlocks: "${each.value.cidr_blocks}",
      description: "${each.value.description}",
      fromPort: "${each.value.from_port}",
      ipv6CidrBlocks: "${each.value.ipv6_cidr_blocks}",
      prefixListIds: "${each.value.prefix_list_ids}",
      protocol: "${each.value.protocol}",
      securityGroups: "${each.value.security_groups}",
      self: "${each.value.self}",
      toPort: "${each.value.to_port}",
    },
  ],
});
new aws.vpc.SecurityGroupRule(this, "docker_machine_docker_runner", {
  description: `\${format(
    "Allow docker-machine traffic from group %s to docker-machine instances in group %s",
    ${awsSecurityGroupRunner.name},
    ${awsSecurityGroupDockerMachine.name}
  )}`,
  fromPort: 2376,
  protocol: "tcp",
  securityGroupId: awsSecurityGroupDockerMachine.id,
  sourceSecurityGroupId: awsSecurityGroupRunner.id,
  toPort: 2376,
  type: "ingress",
});
new aws.vpc.SecurityGroupRule(this, "docker_machine_docker_self", {
  description: `\${format(
    "Allow docker-machine traffic within group %s on port 2376",
    ${awsSecurityGroupDockerMachine.name},
  )}`,
  fromPort: 2376,
  protocol: "tcp",
  securityGroupId: awsSecurityGroupDockerMachine.id,
  self: true,
  toPort: 2376,
  type: "ingress",
});
const awsSecurityGroupRuleDockerMachinePingRunner =
  new aws.vpc.SecurityGroupRule(this, "docker_machine_ping_runner", {
    description: `\${format(
    "Allow ICMP traffic from %s to docker-machine instances in group %s",
    element(${securityGroupsPing}, count.index),
    ${awsSecurityGroupDockerMachine.name}
  )}`,
    fromPort: -1,
    protocol: "icmp",
    securityGroupId: awsSecurityGroupDockerMachine.id,
    sourceSecurityGroupId: `\${element(${securityGroupsPing}, count.index)}`,
    toPort: -1,
    type: "ingress",
  });

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsSecurityGroupRuleDockerMachinePingRunner.addOverride(
  "count",
  `\${length(${securityGroupsPing})}`
);
const awsSecurityGroupRuleDockerMachinePingSelf = new aws.vpc.SecurityGroupRule(
  this,
  "docker_machine_ping_self",
  {
    description: `\${format(
    "Allow ICMP traffic within group %s",
    ${awsSecurityGroupDockerMachine.name},
  )}`,
    fromPort: -1,
    protocol: "icmp",
    securityGroupId: awsSecurityGroupDockerMachine.id,
    self: true,
    toPort: -1,
    type: "ingress",
  }
);

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsSecurityGroupRuleDockerMachinePingSelf.addOverride(
  "count",
  "${var.enable_ping ? 1 : 0}"
);
new aws.vpc.SecurityGroupRule(this, "docker_machine_ssh_runner", {
  description: `\${format(
    "Allow SSH traffic from %s to docker-machine instances in group %s on port 22",
    ${awsSecurityGroupRunner.id},
    ${awsSecurityGroupDockerMachine.name}
  )}`,
  fromPort: 22,
  protocol: "tcp",
  securityGroupId: awsSecurityGroupDockerMachine.id,
  sourceSecurityGroupId: awsSecurityGroupRunner.id,
  toPort: 22,
  type: "ingress",
});
new aws.vpc.SecurityGroupRule(this, "docker_machine_ssh_self", {
  description: `\${format(
    "Allow SSH traffic within group %s on port 22",
    ${awsSecurityGroupDockerMachine.name},
  )}`,
  fromPort: 22,
  protocol: "tcp",
  securityGroupId: awsSecurityGroupDockerMachine.id,
  self: true,
  toPort: 22,
  type: "ingress",
});
const awsSecurityGroupRuleRunnerPingGroup = new aws.vpc.SecurityGroupRule(
  this,
  "runner_ping_group",
  {
    description: `\${format(
    "Allow ICMP traffic from %s to gitlab-runner agent instances in group %s",
    element(var.gitlab_runner_security_group_ids, count.index),
    ${awsSecurityGroupRunner.name}
  )}`,
    fromPort: -1,
    protocol: "icmp",
    securityGroupId: awsSecurityGroupRunner.id,
    sourceSecurityGroupId:
      "${element(var.gitlab_runner_security_group_ids, count.index)}",
    toPort: -1,
    type: "ingress",
  }
);

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsSecurityGroupRuleRunnerPingGroup.addOverride(
  "count",
  "${length(var.gitlab_runner_security_group_ids) > 0 && var.enable_ping ? length(var.gitlab_runner_security_group_ids) : 0}"
);

