/*Provider bindings are generated by running cdktf get.
See https://cdk.tf/provider-generation for more details.*/
import * as aws from "./.gen/providers/aws";
import * as NullProvider from "./.gen/providers/null";
import * as Cache from "./.gen/modules/modules/cache";
const cache = new Cache.Cache(this, "cache", {
  cacheBucketNameIncludeAccountId:
    "${var.cache_bucket_name_include_account_id}",
  cacheBucketPrefix: "${var.cache_bucket_prefix}",
  cacheBucketSetRandomSuffix: "${var.cache_bucket_set_random_suffix}",
  cacheBucketVersioning: "${var.cache_bucket_versioning}",
  cacheExpirationDays: "${var.cache_expiration_days}",
  createCacheBucket: '${var.cache_bucket["create"]}',
  environment: "${var.environment}",
  tags: "${local.tags}",
});
const awsEipGitlabRunner = new aws.ec2.Eip(this, "gitlab_runner", {});

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsEipGitlabRunner.addOverride("count", "${var.enable_eip ? 1 : 0}");
const awsIamPolicyEip = new aws.iam.IamPolicy(this, "eip", {
  description: "Policy for runner to assign EIP",
  name: "${var.environment}-eip",
  path: "/",
  policy: '${templatefile("${path.module}/policies/instance-eip.json", {})}',
  tags: "${local.tags}",
});

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsIamPolicyEip.addOverride("count", "${var.enable_eip ? 1 : 0}");
const awsIamPolicyInstanceSessionManagerPolicy = new aws.iam.IamPolicy(
  this,
  "instance_session_manager_policy",
  {
    description: "Policy session manager.",
    name: "${local.name_iam_objects}-session-manager",
    path: "/",
    policy:
      '${templatefile("${path.module}/policies/instance-session-manager-policy.json", {})}',
    tags: "${local.tags}",
  }
);

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsIamPolicyInstanceSessionManagerPolicy.addOverride(
  "count",
  "${var.enable_runner_ssm_access ? 1 : 0}"
);
const awsIamPolicyServiceLinkedRole = new aws.iam.IamPolicy(
  this,
  "service_linked_role",
  {
    description: "Policy for creation of service linked roles.",
    name: "${local.name_iam_objects}-service_linked_role",
    path: "/",
    policy:
      '${templatefile("${path.module}/policies/service-linked-role-create-policy.json", { arn_format = var.arn_format })}',
    tags: "${local.tags}",
  }
);

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsIamPolicyServiceLinkedRole.addOverride(
  "count",
  "${var.allow_iam_service_linked_role_creation ? 1 : 0}"
);
const awsIamPolicySsm = new aws.iam.IamPolicy(this, "ssm", {
  description: "Policy for runner token param access via SSM",
  name: "${local.name_iam_objects}-ssm",
  path: "/",
  policy:
    '${templatefile("${path.module}/policies/instance-secure-parameter-role-policy.json", { arn_format = var.arn_format })}',
  tags: "${local.tags}",
});

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsIamPolicySsm.addOverride(
  "count",
  "${var.enable_manage_gitlab_token ? 1 : 0}"
);
const awsLaunchTemplateGitlabRunnerInstance = new aws.ec2.LaunchTemplate(
  this,
  "gitlab_runner_instance",
  {
    block_device_mappings: [],
    ebsOptimized: "${var.runner_instance_ebs_optimized}",
    iamInstanceProfile: {
      name: awsIamInstanceProfileInstance.name,
    },
    imageId: dataAwsAmiRunner.id,
    instanceType: "${var.instance_type}",
    metadataOptions: {
      httpEndpoint: "${var.runner_instance_metadata_options_http_endpoint}",
      httpTokens: "${var.runner_instance_metadata_options_http_tokens}",
    },
    monitoring: {
      enabled: "${var.runner_instance_enable_monitoring}",
    },
    namePrefix: "${local.name_runner_agent_instance}",
    networkInterfaces: [
      {
        associatePublicIpAddress:
          "${false == (var.runner_agent_uses_private_address == false ? var.runner_agent_uses_private_address : var.runners_use_private_address)}",
        securityGroups:
          "${concat([aws_security_group.runner.id], var.extra_security_group_ids_runner_agent)}",
      },
    ],
    tagSpecifications: [
      {
        resourceType: "instance",
        tags: "${local.tags}",
      },
      {
        resourceType: "volume",
        tags: "${local.tags}",
      },
    ],
    tags: "${local.tags}",
    updateDefaultVersion: true,
    userData: `\${base64encode(${templateUserData})}`,
  }
);
awsLaunchTemplateGitlabRunnerInstance.addOverride("lifecycle", [
  {
    createBeforeDestroy: true,
  },
]);

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsLaunchTemplateGitlabRunnerInstance.addOverride("block_device_mappings", {
  for_each: ["${var.runner_root_block_device}"],
  content: [
    {
      deviceName:
        '${lookup(block_device_mappings.value, "device_name", "/dev/xvda")}',
      ebs: [
        {
          deleteOnTermination:
            '${lookup(block_device_mappings.value, "delete_on_termination", true)}',
          encrypted:
            '${lookup(block_device_mappings.value, "encrypted", true)}',
          iops: '${lookup(block_device_mappings.value, "iops", null)}',
          kmsKeyId:
            '${lookup(block_device_mappings.value, "kms_key_id", null)}',
          throughput:
            '${lookup(block_device_mappings.value, "throughput", null)}',
          volumeSize:
            '${lookup(block_device_mappings.value, "volume_size", 8)}',
          volumeType:
            '${lookup(block_device_mappings.value, "volume_type", "gp3")}',
        },
      ],
    },
  ],
});
const awsSsmParameterRunnerRegistrationToken = new aws.ssm.SsmParameter(
  this,
  "runner_registration_token",
  {
    name: "${local.secure_parameter_store_runner_token_key}",
    tags: "${local.tags}",
    type: "SecureString",
    value: "null",
  }
);
awsSsmParameterRunnerRegistrationToken.addOverride("lifecycle", [
  {
    ignoreChanges: ["${value}"],
  },
]);
const awsSsmParameterRunnerSentryDsn = new aws.ssm.SsmParameter(
  this,
  "runner_sentry_dsn",
  {
    name: "${local.secure_parameter_store_runner_sentry_dsn}",
    tags: "${local.tags}",
    type: "SecureString",
    value: "null",
  }
);
awsSsmParameterRunnerSentryDsn.addOverride("lifecycle", [
  {
    ignoreChanges: ["${value}"],
  },
]);
const dataAwsAmiDockerMachine = new aws.ec2.DataAwsAmi(this, "docker-machine", {
  filter: [],
  mostRecent: "true",
  owners: "${var.runner_ami_owners}",
});

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
dataAwsAmiDockerMachine.addOverride("filter", {
  for_each: "${var.runner_ami_filter}",
  content: [
    {
      name: "${filter.key}",
      values: "${filter.value}",
    },
  ],
});
const dataAwsAmiRunner = new aws.ec2.DataAwsAmi(this, "runner", {
  filter: [],
  mostRecent: "true",
  owners: "${var.ami_owners}",
});

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
dataAwsAmiRunner.addOverride("filter", {
  for_each: "${var.ami_filter}",
  content: [
    {
      name: "${filter.key}",
      values: "${filter.value}",
    },
  ],
});
const dataAwsCallerIdentityCurrent = new aws.datasources.DataAwsCallerIdentity(
  this,
  "current",
  {}
);
const dataAwsSsmParameterCurrentRunnerRegistrationToken =
  new aws.ssm.DataAwsSsmParameter(this, "current_runner_registration_token", {
    dependsOn: [`\${${awsSsmParameterRunnerRegistrationToken.fqn}}`],
    name: "${local.secure_parameter_store_runner_token_key}",
  });
const dataAwsSubnetRunners = new aws.vpc.DataAwsSubnet(this, "runners", {
  id: "${length(var.subnet_id) > 0 ? var.subnet_id : var.subnet_id_runners}",
});
const templateEip = `\${templatefile("\${path.module}/template/eip.tpl", {
    eip = join(",", ${awsEipGitlabRunner.fqn}.*.public_ip)
  })}`;
const bucketPolicy = `\${var.cache_bucket["create"] ? ${cache.policyArnOutput} : lookup(var.cache_bucket, "policy", "")}`;
const awsAutoscalingGroupGitlabRunnerInstance =
  new aws.autoscaling.AutoscalingGroup(this, "gitlab_runner_instance_14", {
    desiredCapacity: "1",
    enabledMetrics: "${var.metrics_autoscaling}",
    healthCheckGracePeriod: 0,
    instanceRefresh: {
      preferences: {
        minHealthyPercentage: 0,
      },
      strategy: "Rolling",
      triggers: ["tag"],
    },
    launchTemplate: {
      id: awsLaunchTemplateGitlabRunnerInstance.id,
      version: awsLaunchTemplateGitlabRunnerInstance.latestVersion,
    },
    maxInstanceLifetime: "${var.asg_max_instance_lifetime}",
    maxSize: "1",
    minSize: "1",
    name: `\${var.enable_asg_recreation ? "\${${awsLaunchTemplateGitlabRunnerInstance.name}}-asg" : "\${var.environment}-as-group"}`,
    tags: "${local.agent_tags_propagated}",
    timeouts: [
      {
        delete: "${var.asg_delete_timeout}",
      },
    ],
    vpcZoneIdentifier:
      "${length(var.subnet_id) > 0 ? [var.subnet_id] : var.subnet_ids_gitlab_runner}",
  });

/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
awsAutoscalingGroupGitlabRunnerInstance.overrideLogicalId(
  "gitlab_runner_instance"
);
const awsAutoscalingScheduleScaleIn = new aws.autoscaling.AutoscalingSchedule(
  this,
  "scale_in",
  {
    autoscalingGroupName: awsAutoscalingGroupGitlabRunnerInstance.name,
    desiredCapacity: '${var.schedule_config["scale_in_count"]}',
    maxSize: '${var.schedule_config["scale_in_count"]}',
    minSize: '${var.schedule_config["scale_in_count"]}',
    recurrence: '${var.schedule_config["scale_in_recurrence"]}',
    scheduledActionName:
      "scale_in-${aws_autoscaling_group.gitlab_runner_instance.name}",
  }
);

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsAutoscalingScheduleScaleIn.addOverride(
  "count",
  "${var.enable_schedule ? 1 : 0}"
);
const awsAutoscalingScheduleScaleOut = new aws.autoscaling.AutoscalingSchedule(
  this,
  "scale_out",
  {
    autoscalingGroupName: awsAutoscalingGroupGitlabRunnerInstance.name,
    desiredCapacity: '${var.schedule_config["scale_out_count"]}',
    maxSize: '${var.schedule_config["scale_out_count"]}',
    minSize: '${var.schedule_config["scale_out_count"]}',
    recurrence: '${var.schedule_config["scale_out_recurrence"]}',
    scheduledActionName:
      "scale_out-${aws_autoscaling_group.gitlab_runner_instance.name}",
  }
);

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsAutoscalingScheduleScaleOut.addOverride(
  "count",
  "${var.enable_schedule ? 1 : 0}"
);
const awsIamRoleDockerMachine = new aws.iam.IamRole(this, "docker_machine", {
  assumeRolePolicy:
    '${length(var.docker_machine_role_json) > 0 ? var.docker_machine_role_json : templatefile("${path.module}/policies/instance-role-trust-policy.json", {})}',
  name: "${local.name_iam_objects}-docker-machine",
  permissionsBoundary: `\${var.permissions_boundary == "" ? null : "\${var.arn_format}:iam::\${${dataAwsCallerIdentityCurrent.accountId}}:policy/\${var.permissions_boundary}"}`,
  tags: "${local.tags}",
});
const awsIamRoleInstance = new aws.iam.IamRole(this, "instance", {
  assumeRolePolicy:
    '${length(var.instance_role_json) > 0 ? var.instance_role_json : templatefile("${path.module}/policies/instance-role-trust-policy.json", {})}',
  name: "${local.name_iam_objects}-instance",
  permissionsBoundary: `\${var.permissions_boundary == "" ? null : "\${var.arn_format}:iam::\${${dataAwsCallerIdentityCurrent.accountId}}:policy/\${var.permissions_boundary}"}`,
  tags: "${merge(local.tags, var.role_tags)}",
});
const awsIamRolePolicyAttachmentDockerMachineCacheInstance =
  new aws.iam.IamRolePolicyAttachment(this, "docker_machine_cache_instance", {
    policyArn: bucketPolicy,
    role: awsIamRoleInstance.name,
  });

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsIamRolePolicyAttachmentDockerMachineCacheInstance.addOverride(
  "count",
  '${var.cache_bucket["create"] || lookup(var.cache_bucket, "policy", "") != "" ? 1 : 0}'
);
const awsIamRolePolicyAttachmentDockerMachineSessionManagerAwsManaged =
  new aws.iam.IamRolePolicyAttachment(
    this,
    "docker_machine_session_manager_aws_managed",
    {
      policyArn:
        "${var.arn_format}:iam::aws:policy/AmazonSSMManagedInstanceCore",
      role: awsIamRoleDockerMachine.name,
    }
  );

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsIamRolePolicyAttachmentDockerMachineSessionManagerAwsManaged.addOverride(
  "count",
  "${var.enable_docker_machine_ssm_access ? 1 : 0}"
);
const awsIamRolePolicyAttachmentDockerMachineUserDefinedPolicies =
  new aws.iam.IamRolePolicyAttachment(
    this,
    "docker_machine_user_defined_policies",
    {
      policyArn: "${var.docker_machine_iam_policy_arns[count.index]}",
      role: awsIamRoleDockerMachine.name,
    }
  );

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsIamRolePolicyAttachmentDockerMachineUserDefinedPolicies.addOverride(
  "count",
  "${length(var.docker_machine_iam_policy_arns)}"
);
const awsIamRolePolicyAttachmentEip = new aws.iam.IamRolePolicyAttachment(
  this,
  "eip_22",
  {
    policyArn: `\${${awsIamPolicyEip.fqn}[0].arn}`,
    role: awsIamRoleInstance.name,
  }
);

/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
awsIamRolePolicyAttachmentEip.overrideLogicalId("eip");

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsIamRolePolicyAttachmentEip.addOverride("count", "${var.enable_eip ? 1 : 0}");
const awsIamRolePolicyAttachmentInstanceSessionManagerAwsManaged =
  new aws.iam.IamRolePolicyAttachment(
    this,
    "instance_session_manager_aws_managed",
    {
      policyArn:
        "${var.arn_format}:iam::aws:policy/AmazonSSMManagedInstanceCore",
      role: awsIamRoleInstance.name,
    }
  );

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsIamRolePolicyAttachmentInstanceSessionManagerAwsManaged.addOverride(
  "count",
  "${var.enable_runner_ssm_access ? 1 : 0}"
);
const awsIamRolePolicyAttachmentInstanceSessionManagerPolicy =
  new aws.iam.IamRolePolicyAttachment(
    this,
    "instance_session_manager_policy_24",
    {
      policyArn: `\${${awsIamPolicyInstanceSessionManagerPolicy.fqn}[0].arn}`,
      role: awsIamRoleInstance.name,
    }
  );

/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
awsIamRolePolicyAttachmentInstanceSessionManagerPolicy.overrideLogicalId(
  "instance_session_manager_policy"
);

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsIamRolePolicyAttachmentInstanceSessionManagerPolicy.addOverride(
  "count",
  "${var.enable_runner_ssm_access ? 1 : 0}"
);
const awsIamRolePolicyAttachmentServiceLinkedRole =
  new aws.iam.IamRolePolicyAttachment(this, "service_linked_role_25", {
    policyArn: `\${${awsIamPolicyServiceLinkedRole.fqn}[0].arn}`,
    role: awsIamRoleInstance.name,
  });

/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
awsIamRolePolicyAttachmentServiceLinkedRole.overrideLogicalId(
  "service_linked_role"
);

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsIamRolePolicyAttachmentServiceLinkedRole.addOverride(
  "count",
  "${var.allow_iam_service_linked_role_creation ? 1 : 0}"
);
const awsIamRolePolicyAttachmentSsm = new aws.iam.IamRolePolicyAttachment(
  this,
  "ssm_26",
  {
    policyArn: `\${${awsIamPolicySsm.fqn}[0].arn}`,
    role: awsIamRoleInstance.name,
  }
);

/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
awsIamRolePolicyAttachmentSsm.overrideLogicalId("ssm");

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsIamRolePolicyAttachmentSsm.addOverride(
  "count",
  "${var.enable_manage_gitlab_token ? 1 : 0}"
);
const awsIamRolePolicyAttachmentUserDefinedPolicies =
  new aws.iam.IamRolePolicyAttachment(this, "user_defined_policies", {
    policyArn: "${var.runner_iam_policy_arns[count.index]}",
    role: awsIamRoleInstance.name,
  });

/*In most cases loops should be handled in the programming language context and 
not inside of the Terraform context. If you are looping over something external, e.g. a variable or a file input
you should consider using a for loop. If you are looping over something only known to Terraform, e.g. a result of a data source
you need to keep this like it is.*/
awsIamRolePolicyAttachmentUserDefinedPolicies.addOverride(
  "count",
  "${length(var.runner_iam_policy_arns)}"
);
new NullProvider.Resource(this, "remove_runner", {
  dependsOn: [`\${${awsSsmParameterRunnerRegistrationToken.fqn}}`],
  provisioner: [
    {
      localExec: [
        {
          command:
            'curl -sS --request DELETE "${self.triggers.runners_gitlab_url}/api/v4/runners" --form "token=${self.triggers.runner_registration_token}"',
          onFailure: "${continue}",
          when: "${destroy}",
        },
      ],
    },
  ],
  triggers: [
    {
      awsRegion: "${var.aws_region}",
      runnerRegistrationToken:
        dataAwsSsmParameterCurrentRunnerRegistrationToken.value,
      runnersGitlabUrl: "${var.runners_gitlab_url}",
    },
  ],
});
const dataAwsAvailabilityZoneRunners =
  new aws.datasources.DataAwsAvailabilityZone(this, "runners_29", {
    name: dataAwsSubnetRunners.availabilityZone,
  });

/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
dataAwsAvailabilityZoneRunners.overrideLogicalId("runners");
const templateRunnerConfig = `\${templatefile("\${path.module}/template/runner-config.tpl",
    {
      aws_region                  = var.aws_region
      gitlab_url                  = var.runners_gitlab_url
      runners_vpc_id              = var.vpc_id
      runners_subnet_id           = length(var.subnet_id) > 0 ? var.subnet_id : var.subnet_id_runners
      runners_aws_zone            = ${dataAwsAvailabilityZoneRunners.nameSuffix}
      runners_instance_type       = var.docker_machine_instance_type
      runners_spot_price_bid      = var.docker_machine_spot_price_bid == "on-demand-price" ? "" : var.docker_machine_spot_price_bid
      runners_ami                 = data.aws_ami.docker-machine.id
      runners_security_group_name = aws_security_group.docker_machine.name
      runners_monitoring          = var.runners_monitoring
      runners_ebs_optimized       = var.runners_ebs_optimized
      runners_instance_profile    = aws_iam_instance_profile.docker_machine.name
      runners_additional_volumes  = local.runners_additional_volumes
      docker_machine_options      = length(local.docker_machine_options_string) == 1 ? "" : local.docker_machine_options_string
      runners_name                = var.runners_name
      runners_tags = replace(var.overrides["name_docker_machine_runners"] == "" ? format(
        "Name,%s-docker-machine,%s,%s",
        var.environment,
        local.tags_string,
        local.runner_tags_string,
        ) : format(
        "%s,%s,Name,%s",
        local.tags_string,
        local.runner_tags_string,
        var.overrides["name_docker_machine_runners"],
      ), ",,", ",")
      runners_token                     = var.runners_token
      runners_executor                  = var.runners_executor
      runners_limit                     = var.runners_limit
      runners_concurrent                = var.runners_concurrent
      runners_image                     = var.runners_image
      runners_privileged                = var.runners_privileged
      runners_disable_cache             = var.runners_disable_cache
      runners_docker_runtime            = var.runners_docker_runtime
      runners_helper_image              = var.runners_helper_image
      runners_shm_size                  = var.runners_shm_size
      runners_pull_policy               = var.runners_pull_policy
      runners_idle_count                = var.runners_idle_count
      runners_idle_time                 = var.runners_idle_time
      runners_max_builds                = local.runners_max_builds_string
      runners_machine_autoscaling       = local.runners_machine_autoscaling
      runners_root_size                 = var.runners_root_size
      runners_iam_instance_profile_name = var.runners_iam_instance_profile_name
      runners_use_private_address_only  = var.runners_use_private_address
      runners_use_private_address       = !var.runners_use_private_address
      runners_request_spot_instance     = var.runners_request_spot_instance
      runners_environment_vars          = jsonencode(var.runners_environment_vars)
      runners_pre_build_script          = var.runners_pre_build_script
      runners_post_build_script         = var.runners_post_build_script
      runners_pre_clone_script          = var.runners_pre_clone_script
      runners_request_concurrency       = var.runners_request_concurrency
      runners_output_limit              = var.runners_output_limit
      runners_check_interval            = var.runners_check_interval
      runners_volumes_tmpfs             = join(",", [for v in var.runners_volumes_tmpfs : format("\"%s\" = \"%s\"", v.volume, v.options)])
      runners_services_volumes_tmpfs    = join(",", [for v in var.runners_services_volumes_tmpfs : format("\"%s\" = \"%s\"", v.volume, v.options)])
      bucket_name                       = local.bucket_name
      shared_cache                      = var.cache_shared
      sentry_dsn                        = var.sentry_dsn
    }
  )}`;
const awsIamInstanceProfileDockerMachine = new aws.iam.IamInstanceProfile(
  this,
  "docker_machine_30",
  {
    name: "${local.name_iam_objects}-docker-machine",
    role: awsIamRoleDockerMachine.name,
    tags: "${local.tags}",
  }
);

/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
awsIamInstanceProfileDockerMachine.overrideLogicalId("docker_machine");
const awsIamInstanceProfileInstance = new aws.iam.IamInstanceProfile(
  this,
  "instance_31",
  {
    name: "${local.name_iam_objects}-instance",
    role: awsIamRoleInstance.name,
    tags: "${local.tags}",
  }
);

/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
awsIamInstanceProfileInstance.overrideLogicalId("instance");
const awsIamPolicyInstanceDockerMachinePolicy = new aws.iam.IamPolicy(
  this,
  "instance_docker_machine_policy",
  {
    description: "Policy for docker machine.",
    name: "${local.name_iam_objects}-docker-machine",
    path: "/",
    policy: `\${templatefile("\${path.module}/policies/instance-docker-machine-policy.json",
    {
      docker_machine_role_arn = ${awsIamRoleDockerMachine.arn}
  })}`,
    tags: "${local.tags}",
  }
);
const awsIamRolePolicyAttachmentInstanceDockerMachinePolicy =
  new aws.iam.IamRolePolicyAttachment(
    this,
    "instance_docker_machine_policy_33",
    {
      policyArn: awsIamPolicyInstanceDockerMachinePolicy.arn,
      role: awsIamRoleInstance.name,
    }
  );

/*This allows the Terraform resource name to match the original name. You can remove the call if you don't need them to match.*/
awsIamRolePolicyAttachmentInstanceDockerMachinePolicy.overrideLogicalId(
  "instance_docker_machine_policy"
);
const templateGitlabRunner = `\${templatefile("\${path.module}/template/gitlab-runner.tpl",
    {
      gitlab_runner_version                        = var.gitlab_runner_version
      docker_machine_version                       = var.docker_machine_version
      docker_machine_download_url                  = var.docker_machine_download_url
      runners_config                               = ${templateRunnerConfig}
      runners_executor                             = var.runners_executor
      runners_install_amazon_ecr_credential_helper = var.runners_install_amazon_ecr_credential_helper
      pre_install                                  = var.userdata_pre_install
      post_install                                 = var.userdata_post_install
      runners_gitlab_url                           = var.runners_gitlab_url
      runners_token                                = var.runners_token
      secure_parameter_store_runner_token_key      = local.secure_parameter_store_runner_token_key
      secure_parameter_store_runner_sentry_dsn     = local.secure_parameter_store_runner_sentry_dsn
      secure_parameter_store_region                = var.aws_region
      gitlab_runner_registration_token             = var.gitlab_runner_registration_config["registration_token"]
      giltab_runner_description                    = var.gitlab_runner_registration_config["description"]
      gitlab_runner_tag_list                       = var.gitlab_runner_registration_config["tag_list"]
      gitlab_runner_locked_to_project              = var.gitlab_runner_registration_config["locked_to_project"]
      gitlab_runner_run_untagged                   = var.gitlab_runner_registration_config["run_untagged"]
      gitlab_runner_maximum_timeout                = var.gitlab_runner_registration_config["maximum_timeout"]
      gitlab_runner_access_level                   = lookup(var.gitlab_runner_registration_config, "access_level", "not_protected")
      sentry_dsn                                   = var.sentry_dsn
  })}`;

